type Value__2 = 
 variant {
   Array: vec Value__2;
   Blob: blob;
   Int: int;
   Map: Map;
   Nat: nat;
   Nat64: nat64;
   Text: text;
 };
type Value__1 = 
 variant {
   Array: vec Value__1;
   Blob: blob;
   Int: int;
   Map: vec record {
              text;
              Value__1;
            };
   Nat: nat;
   Text: text;
 };
type Value = 
 variant {
   Array: vec Value;
   Blob: blob;
   Int: int;
   Map: vec record {
              text;
              Value;
            };
   Nat: nat;
   Text: text;
 };
type UpdateLedgerInfoRequest__2 = 
 variant {
   Decimals: nat8;
   Fee: Fee;
   FeeCollector: opt Account;
   Logo: text;
   MaxAccounts: nat;
   MaxMemo: nat;
   MaxSupply: opt nat;
   Metadata: record {
               text;
               opt Value;
             };
   MinBurnAmount: opt nat;
   MintingAccount: Account;
   Name: text;
   PermittedDrift: nat64;
   SettleToAccounts: nat;
   Symbol: text;
   TransactionWindow: nat64;
 };
type UpdateLedgerInfoRequest__1 = 
 variant {
   Fee: Fee__1;
   MaxAllowance: opt MaxAllowance;
   MaxApprovals: nat;
   MaxApprovalsPerAccount: nat;
   SettleToApprovals: nat;
 };
type UpdateLedgerInfoRequest = 
 variant {
   Fee: Fee__1;
   MaxBalances: nat;
   MaxTransfers: nat;
 };
type TxIndex = nat;
type Transfer__1 = 
 record {
   amount: nat;
   created_at_time: opt nat64;
   fee: opt nat;
   from: Account__5;
   memo: opt blob;
   spender: opt Account__5;
   to: Account__5;
 };
type TransferResult = 
 variant {
   Err: TransferError;
   Ok: TxIndex;
 };
type TransferFromResponse = 
 variant {
   Err: TransferFromError;
   Ok: nat;
 };
type TransferFromError = 
 variant {
   BadBurn: record {min_burn_amount: nat;};
   BadFee: record {expected_fee: nat;};
   CreatedInFuture: record {ledger_time: nat64;};
   Duplicate: record {duplicate_of: nat;};
   GenericError: record {
                   error_code: nat;
                   message: text;
                 };
   InsufficientAllowance: record {allowance: nat;};
   InsufficientFunds: record {balance: nat;};
   TemporarilyUnavailable;
   TooOld;
 };
type TransferFromArgs = 
 record {
   amount: nat;
   created_at_time: opt nat64;
   fee: opt nat;
   from: Account;
   memo: opt blob;
   spender_subaccount: opt blob;
   to: Account;
 };
type TransferError = 
 variant {
   BadBurn: record {min_burn_amount: Balance;};
   BadFee: record {expected_fee: Balance;};
   CreatedInFuture: record {ledger_time: Timestamp;};
   Duplicate: record {duplicate_of: TxIndex;};
   GenericError: record {
                   error_code: nat;
                   message: text;
                 };
   InsufficientFunds: record {balance: Balance;};
   TemporarilyUnavailable;
   TooOld;
 };
type TransferBatchResults = vec opt TransferBatchResult;
type TransferBatchResult = 
 variant {
   Err: TransferBatchError;
   Ok: nat;
 };
type TransferBatchError = 
 variant {
   BadBurn: record {min_burn_amount: nat;};
   BadFee: record {expected_fee: nat;};
   CreatedInFuture: record {ledger_time: nat64;};
   Duplicate: record {duplicate_of: nat;};
   GenericBatchError: record {
                        error_code: nat;
                        message: text;
                      };
   GenericError: record {
                   error_code: nat;
                   message: text;
                 };
   InsufficientFunds: record {balance: nat;};
   TemporarilyUnavailable;
   TooManyRequests: record {limit: nat;};
   TooOld;
 };
type TransferBatchArgs = vec TransferArgs;
type TransferArgs = 
 record {
   amount: Balance;
   created_at_time: opt Timestamp;
   fee: opt Balance;
   from_subaccount: opt Subaccount;
   memo: opt Memo;
   to: Account;
 };
type Transfer = 
 record {
   amount: Balance;
   created_at_time: opt Timestamp;
   fee: opt Balance;
   from: Account;
   memo: opt Memo;
   to: Account;
 };
type Transaction__1 = 
 record {
   approve: opt Approve;
   burn: opt Burn__1;
   kind: text;
   mint: opt Mint__2;
   timestamp: nat64;
   transfer: opt Transfer__1;
 };
type TransactionRange = 
 record {
   length: nat;
   start: nat;
 };
type Transaction = 
 record {
   burn: opt Burn;
   index: TxIndex;
   kind: text;
   mint: opt Mint;
   timestamp: Timestamp;
   transfer: opt Transfer;
 };
type Token = 
 service {
   admin_init: () -> ();
   /// Configure the index canister for push notifications
   /// Set to null to disable notifications
   admin_set_index_canister: ("principal": opt principal) -> (bool);
   admin_update_icrc1: (requests: vec UpdateLedgerInfoRequest__2) ->
    (vec bool);
   admin_update_icrc2: (requests: vec UpdateLedgerInfoRequest__1) ->
    (vec bool);
   admin_update_icrc4: (requests: vec UpdateLedgerInfoRequest) -> (vec bool);
   admin_update_owner: (new_owner: principal) -> (bool);
   archives: () -> (vec LegacyArchiveInfo);
   burn: (args: BurnArgs) -> (TransferResult);
   deposit_cycles: () -> ();
   getUpgradeError: () -> (text) query;
   get_blocks: (args: record {
                        length: nat;
                        start: nat;
                      }) -> (RosettaGetBlocksResponse) query;
   /// Legacy Rosetta-compatible alias for icrc3_get_tip_certificate.
   /// Returns { certificate: opt blob; hash_tree: blob } to match SNS ledger interface.
   get_data_certificate: () ->
    (record {
       certificate: opt blob;
       hash_tree: blob;
     }) query;
   get_icrc85_stats: () ->
    (record {
       activeActions: nat;
       lastActionReported: opt nat;
       nextCycleActionId: opt nat;
     }) query;
   /// Get the currently configured index canister
   get_index_canister: () -> (opt principal) query;
   get_tip: () -> (Tip) query;
   get_transactions: (args: record {
                              length: nat;
                              start: nat;
                            }) -> (GetTransactionsResponse) query;
   icrc103_get_allowances: (args: GetAllowancesArgs) ->
    (AllowanceResult) query;
   icrc106_get_index_principal: () -> (Icrc106GetResult) query;
   icrc107_get_fee_collector: () -> (GetFeeCollectorResult) query;
   icrc107_set_fee_collector: (args: SetFeeCollectorArgs) ->
    (SetFeeCollectorResult);
   icrc10_supported_standards: () -> (vec SupportedStandard) query;
   icrc1_balance_of: (args: Account) -> (Balance) query;
   icrc1_decimals: () -> (nat8) query;
   icrc1_fee: () -> (Balance) query;
   icrc1_metadata: () -> (vec MetaDatum) query;
   icrc1_minting_account: () -> (opt Account) query;
   /// Functions for the ICRC1 token standard
   icrc1_name: () -> (text) query;
   icrc1_supported_standards: () -> (vec SupportedStandard) query;
   icrc1_symbol: () -> (text) query;
   icrc1_total_supply: () -> (Balance) query;
   icrc1_transfer: (args: TransferArgs) -> (TransferResult);
   icrc21_canister_call_consent_message: (request: ConsentMessageRequest) ->
    (ConsentMessageResponse);
   icrc2_allowance: (args: AllowanceArgs) -> (Allowance) query;
   icrc2_approve: (args: ApproveArgs) -> (ApproveResponse);
   icrc2_transfer_from: (args: TransferFromArgs) -> (TransferFromResponse);
   icrc3_get_archives: (args: GetArchivesArgs) -> (GetArchivesResult) query;
   icrc3_get_blocks: (args: GetBlocksArgs) -> (GetBlocksResult) query;
   icrc3_get_tip_certificate: () -> (opt DataCertificate) query;
   icrc3_supported_block_types: () -> (vec BlockType) query;
   icrc4_balance_of_batch: (request: BalanceQueryArgs) ->
    (BalanceQueryResult) query;
   icrc4_maximum_query_batch_size: () -> (opt nat) query;
   icrc4_maximum_update_batch_size: () -> (opt nat) query;
   icrc4_transfer_batch: (args: TransferBatchArgs) -> (TransferBatchResults);
   /// SNS parity: returns true once the ledger is initialized and ready.
   is_ledger_ready: () -> (bool) query;
   mint: (args: Mint) -> (TransferResult);
   set_icrc106_index_principal: ("principal": opt principal) -> ();
   update_archive_controllers: () -> ();
   upgradeArchive: (bOverride: bool) -> ();
 };
type Tip = 
 record {
   hash_tree: blob;
   last_block_hash: blob;
   last_block_index: blob;
 };
type Timestamp = nat64;
type SupportedStandard = 
 record {
   name: text;
   url: text;
 };
type Subaccount = blob;
type SetFeeCollectorResult = 
 variant {
   Err: SetFeeCollectorError;
   Ok: nat;
 };
type SetFeeCollectorError = 
 variant {
   AccessDenied: text;
   CreatedInFuture: record {ledger_time: nat64;};
   Duplicate: record {duplicate_of: nat;};
   GenericError: record {
                   error_code: nat;
                   message: text;
                 };
   InvalidAccount: text;
   TooOld;
 };
type SetFeeCollectorArgs = 
 record {
   created_at_time: nat64;
   fee_collector: opt Account;
 };
type RosettaGetBlocksResponse = 
 record {
   archived_blocks: vec RosettaArchivedRange;
   blocks: vec Value__2;
   certificate: opt blob;
   chain_length: nat64;
   first_index: nat;
 };
type RosettaBlockRange = record {blocks: vec Value__2;};
type RosettaArchivedRange = 
 record {
   callback: func (GetBlocksRequest) -> (RosettaBlockRange) query;
   length: nat;
   start: nat;
 };
type Mint__2 = 
 record {
   amount: nat;
   created_at_time: opt nat64;
   memo: opt blob;
   to: Account__5;
 };
type Mint = 
 record {
   amount: Balance;
   created_at_time: opt Timestamp;
   memo: opt Memo;
   to: Account;
 };
type MetaDatum = 
 record {
   text;
   Value;
 };
type Memo = blob;
type MaxAllowance = 
 variant {
   Fixed: nat;
   TotalSupply;
 };
type Map = 
 vec record {
       text;
       Value__2;
     };
type LegacyArchivedRange = 
 record {
   callback: GetLegacyArchiveTransactionFunction;
   length: nat;
   start: nat;
 };
type LegacyArchiveInfo = 
 record {
   block_range_end: nat;
   block_range_start: nat;
   canister_id: principal;
 };
type InitArgs__3 = 
 record {
   fee: opt Fee__1;
   max_balances: opt nat;
   max_transfers: opt nat;
 };
type InitArgs__2 = 
 record {
   archiveControllers: opt opt vec principal;
   archiveCycles: nat;
   archiveIndexType: IndexType;
   maxActiveRecords: nat;
   maxArchivePages: nat;
   maxRecordsInArchiveInstance: nat;
   maxRecordsToArchive: nat;
   settleToRecords: nat;
   supportedBlocks: vec BlockType;
 };
type InitArgs__1 = 
 record {
   advanced_settings: opt AdvancedSettings__1;
   cleanup_interval: opt nat;
   cleanup_on_zero_balance: opt bool;
   fee: opt Fee__1;
   icrc103_max_take_value: opt nat;
   icrc103_public_allowances: opt bool;
   max_allowance: opt MaxAllowance;
   max_approvals: opt nat;
   max_approvals_per_account: opt nat;
   settle_to_approvals: opt nat;
 };
type InitArgs = 
 record {
   advanced_settings: opt AdvancedSettings;
   decimals: nat8;
   fee: opt Fee;
   fee_collector: opt Account;
   logo: opt text;
   max_accounts: opt nat;
   max_memo: opt nat;
   max_supply: opt Balance;
   metadata: opt Value;
   min_burn_amount: opt Balance;
   minting_account: opt Account;
   name: opt text;
   permitted_drift: opt Timestamp;
   settle_to_accounts: opt nat;
   symbol: opt text;
   transaction_window: opt Timestamp;
 };
type IndexType = 
 variant {
   Managed;
   Stable;
   StableTyped;
 };
type Icrc21Error = 
 variant {
   ConsentMessageUnavailable: ErrorInfo;
   GenericError: record {
                   description: text;
                   error_code: nat;
                 };
   InsufficientPayment: ErrorInfo;
   UnsupportedCanisterCall: ErrorInfo;
 };
type Icrc106GetResult = 
 variant {
   Err: Icrc106Error;
   Ok: principal;
 };
type Icrc106Error = 
 variant {
   GenericError: record {
                   description: text;
                   error_code: nat;
                 };
   IndexPrincipalNotSet;
 };
type GetTransactionsResult = 
 record {
   archived_blocks: vec ArchivedTransactionResponse;
   blocks: vec record {
                 block: Value__1;
                 id: nat;
               };
   log_length: nat;
 };
type GetTransactionsResponse = 
 record {
   archived_transactions: vec LegacyArchivedRange;
   first_index: nat;
   log_length: nat;
   transactions: vec Transaction__1;
 };
type GetTransactionsFn = func (vec TransactionRange) ->
                          (GetTransactionsResult) query;
type GetLegacyArchiveTransactionFunction = func (GetBlocksRequest) ->
                                            (GetArchiveTransactionsResponse) query;
type GetFeeCollectorResult = 
 variant {
   Err: GetFeeCollectorError;
   Ok: opt Account;
 };
type GetFeeCollectorError = variant {
                              GenericError:
                               record {
                                 error_code: nat;
                                 message: text;
                               };};
type GetBlocksResult = 
 record {
   archived_blocks: vec ArchivedTransactionResponse;
   blocks: vec record {
                 block: Value__1;
                 id: nat;
               };
   log_length: nat;
 };
type GetBlocksRequest = 
 record {
   length: nat;
   start: nat;
 };
type GetBlocksArgs = vec TransactionRange;
type GetArchivesResultItem = 
 record {
   canister_id: principal;
   end: nat;
   start: nat;
 };
type GetArchivesResult = vec GetArchivesResultItem;
type GetArchivesArgs = record {from: opt principal;};
type GetArchiveTransactionsResponse = record {
                                        transactions: vec Transaction__1;};
type GetAllowancesError = 
 variant {
   AccessDenied: record {reason: text;};
   GenericError: record {
                   error_code: nat;
                   message: text;
                 };
 };
type GetAllowancesArgs = 
 record {
   from_account: opt Account;
   prev_spender: opt Account;
   take: opt nat;
 };
type Fee__1 = 
 variant {
   Environment;
   Fixed: nat;
   ICRC1;
 };
type Fee = 
 variant {
   Environment;
   Fixed: nat;
 };
type ErrorInfo = record {description: text;};
type DisplayValue = 
 variant {
   DurationSeconds: record {amount: nat64;};
   Text: record {content: text;};
   TimestampSeconds: record {amount: nat64;};
   TokenAmount: record {
                  amount: nat64;
                  decimals: nat8;
                  symbol: text;
                };
 };
type DataCertificate = 
 record {
   certificate: blob;
   hash_tree: blob;
 };
type ConsentMessageSpec = 
 record {
   device_spec: opt variant {
                      FieldsDisplay;
                      GenericDisplay;
                    };
   metadata: ConsentMessageMetadata;
 };
type ConsentMessageResponse = 
 variant {
   Err: Icrc21Error;
   Ok: ConsentInfo;
 };
type ConsentMessageRequest = 
 record {
   arg: blob;
   method: text;
   user_preferences: ConsentMessageSpec;
 };
type ConsentMessageMetadata = 
 record {
   language: text;
   utc_offset_minutes: opt int16;
 };
type ConsentMessage = 
 variant {
   FieldsDisplayMessage:
    record {
      fields: vec record {
                    text;
                    DisplayValue;
                  };
      intent: text;
    };
   GenericDisplayMessage: text;
 };
type ConsentInfo = 
 record {
   consent_message: ConsentMessage;
   metadata: ConsentMessageMetadata;
 };
type Burn__1 = 
 record {
   amount: nat;
   created_at_time: opt nat64;
   from: Account__5;
   memo: opt blob;
   spender: opt Account__5;
 };
type BurnArgs = 
 record {
   amount: Balance;
   created_at_time: opt Timestamp;
   from_subaccount: opt Subaccount;
   memo: opt Memo;
 };
type Burn = 
 record {
   amount: Balance;
   created_at_time: opt Timestamp;
   from: Account;
   memo: opt Memo;
 };
type BlockType = 
 record {
   block_type: text;
   url: text;
 };
type BalanceQueryResult = vec nat;
type BalanceQueryArgs = record {accounts: vec Account;};
type Balance = nat;
type ArchivedTransactionResponse = 
 record {
   args: vec TransactionRange;
   callback: GetTransactionsFn;
 };
type ApproveResponse = 
 variant {
   Err: ApproveError;
   Ok: nat;
 };
type ApproveError = 
 variant {
   AllowanceChanged: record {current_allowance: nat;};
   BadFee: record {expected_fee: nat;};
   CreatedInFuture: record {ledger_time: nat64;};
   Duplicate: record {duplicate_of: nat;};
   Expired: record {ledger_time: nat64;};
   GenericError: record {
                   error_code: nat;
                   message: text;
                 };
   InsufficientFunds: record {balance: nat;};
   TemporarilyUnavailable;
   TooOld;
 };
type ApproveArgs = 
 record {
   amount: nat;
   created_at_time: opt nat64;
   expected_allowance: opt nat;
   expires_at: opt nat64;
   fee: opt nat;
   from_subaccount: opt blob;
   memo: opt blob;
   spender: Account;
 };
type Approve = 
 record {
   amount: nat;
   created_at_time: opt nat64;
   expected_allowance: opt nat;
   expires_at: opt nat64;
   fee: opt nat;
   from: Account__5;
   memo: opt blob;
   spender: Account__5;
 };
type ApprovalInfo = 
 record {
   amount: nat;
   expires_at: opt nat64;
   from_subaccount: opt blob;
   spender: Account;
 };
type AllowanceResult = 
 variant {
   Err: GetAllowancesError;
   Ok: vec AllowanceDetail;
 };
type AllowanceDetail = 
 record {
   allowance: nat;
   expires_at: opt nat64;
   from_account: Account;
   to_spender: Account;
 };
type AllowanceArgs = 
 record {
   account: Account;
   spender: Account;
 };
type Allowance = 
 record {
   allowance: nat;
   expires_at: opt nat64;
 };
type AdvancedSettings__1 = record {
                             existing_approvals:
                              vec
                               record {
                                 record {
                                   Account;
                                   Account;
                                 };
                                 ApprovalInfo;
                               };};
type AdvancedSettings = 
 record {
   burned_tokens: Balance;
   existing_balances: vec record {
                            Account;
                            Balance;
                          };
   fee_collector_block: nat;
   fee_collector_emitted: bool;
   local_transactions: vec Transaction;
   minted_tokens: Balance;
 };
type Account__5 = 
 record {
   owner: principal;
   subaccount: opt blob;
 };
type Account = 
 record {
   owner: principal;
   subaccount: opt Subaccount;
 };
service : (args: opt
                  record {
                    icrc1: opt InitArgs;
                    icrc2: opt InitArgs__1;
                    icrc3: InitArgs__2;
                    icrc4: opt InitArgs__3;
                  }) -> Token
